#ANN Class
import numpy as np
import Bird as Bird_Class
from settings import *
import sys
import random

class ANN:
    def __init__(self, genome = None):
        self.fitness = 0
        self.weight1 = np.random.uniform(-1,1,(HIDDEN_LAYER, INPUT_LAYER + 1))#add bias node by adding 1 to input layer
        self.weight2 = np.random.uniform(-1,1,(OUTPUT_LAYER, HIDDEN_LAYER + 1))

        if genome is not None: #if constructor have genome then use that genome for weight
            self.decode(genome)

    def __sigmoid(self,np_array): #private method in ANN class, apply sigmoid function to numpy array
        return 1.0 / (1.0 + np.exp(-1.0 * np_array))

    def __regularize_input(self, list_input): #regularize input, make it between 0 and 1
        if np.shape(list_input) != (INPUT_LAYER,1): #check dimension of input
            sys.exit('INPUT to Neural Nets doesnt match')

        sum = np.sum(abs(list_input))

        for array in list_input:
            if sum == 0:
                array[0] = 0
            else:
                array[0] = array[0]/sum

    #This function return a number x, if x > threshold then bird.flap()
    def feed_forward(self, list_input): #list_input muse be numpy array dim(2,1)
        if np.shape(list_input) != (INPUT_LAYER,1): #check dimension of input
            sys.exit('INPUT to Neural Nets doesnt match')

        self.__regularize_input(list_input)#regularize input, make it between 0 and 1

        nodes_hidden_layer = np.dot(self.weight1, np.concatenate((np.array([[1]]), list_input),axis = 0)) #concatenate vertically, using matrix multiplication on weight and nodes

        activation_hidden_layer = self.__sigmoid(nodes_hidden_layer) #apply sigmoid activation on hidden layer

        node_output_layer = np.dot(self.weight2, np.concatenate((np.array([[1]]), activation_hidden_layer),axis = 0)) #matrix multiplication of weight and activation to create final output

        return self.__sigmoid(node_output_layer) #apply sigmoid function on final output

    def encode(self): #put all weight into a list double

        genome = [] #write each row from left to right

        for row in range(self.weight1.shape[0]): #read each row first
            for row_element in range(self.weight1.shape[1]): #read element of row from left to right
                genome.append(self.weight1[row][row_element])

        for row in range(self.weight2.shape[0]):
            for row_element in range(self.weight2.shape[1]):
                genome.append(self.weight2[row][row_element])

        return genome

    def decode(self, genome): #read weight from genome
        for i in range(HIDDEN_LAYER): #read genome from left to right
            for j in range(INPUT_LAYER+1):
                self.weight1[i][j] = genome[i*(INPUT_LAYER+1)+j]

        for i in range(OUTPUT_LAYER):
            for j in range(HIDDEN_LAYER+1):
                self.weight2[i][j] = genome[(i*(OUTPUT_LAYER)) + j + HIDDEN_LAYER*(INPUT_LAYER+1)]

    @classmethod #class method is some method that must be call with class, like ANN.selection but the only thing they care about is the parameter
    def selection(cls, bird_list):
        elite_birds_copy = [] #create a copy of list to put all elite bird in to avoid inconsistency problem
        elite_birds =  bird_list[0:round(SELECTION_PERCENTAGE*POPULATION)]

        for bird in elite_birds:
            gen = bird.ANN.encode() #encode to gen
            elite_birds_copy.append(Bird_Class.Bird(gen)) #decode gen to read weight

        return elite_birds_copy

    @classmethod
    def mutation(cls, bird): #change some weights randomly
        gen = bird.ANN.encode()

        for i in range(TOTAL_WEIGHT):
            if (np.random.rand(0,100) < MUTATION_RATE*100):
                gen[i] = np.random.uniform(-1,1) #random float from -1 to 1

        new_bird = Bird_Class.Bird(gen)

        return new_bird

    @classmethod #swap weight with certain chance (MUTATION RATE)
    def crossover(cls, bird1, bird2): #swap weight
        gen_bird1 = bird1.ANN.encode() #mutation on a gene so that the actual bird.ANN will not be change
        gen_bird2 = bird2.ANN.encode()

        for i in gen_bird1:
            if (np.random.rand(0,100) < CROSSOVER_RATE*100): #Create a random number from 0 and 100 and check with possibility of CROSSOVER_RATE
                gen_bird1[i], gen_bird2[i] = gen_bird2[i], gen_bird1[1]

        return [Bird_Class.Bird(gen_bird1), Bird_Class.Bird(gen_bird2)]

    @classmethod
    def save_weight(cls):
        pass

    @classmethod
    def create_new_generation(cls, bird_list):
        new_generation = []

        #selection
        elite_birds = ANN.selection(bird_list)
        new_generation.extend(elite_birds)

        #mutation
        for i in range(0, round(MUTATION_PERCENTAGE*100/POPULATION)):
           new_generation.append(ANN.mutation(bird_list[i]))

        # crossover with the elite birds
        for i in range(round((MUTATION_PERCENTAGE*100/POPULATION)), round(((MUTATION_PERCENTAGE*100/POPULATION) + (CROSSOVER_PERCENTAGE*100/POPULATION)))):
            new_generation.append(ANN.crossover(bird_list[i], elite_birds[random.randint(0,len(elite_birds)-1)])[0])

        #random bird to increase diversity
        for i in range(POPULATION-len(new_generation)):
            new_generation.append(Bird_Class.Bird())

        return new_generation

#Barrier_factory class
from Sky import *
from Bird import *
from Ground import *
from settings import *
import random

#Design Pattern : Factory
class Barrier_Factory:
    def __init__(self):
        self.index = 0
        self.__list_tube_height = []

        for i in range(1,3000):
            self.__list_tube_height.append(random.randint(10,HEIGHT - SAND_HEIGHT - TUBE_GAP- 10))

        self.count = 0

        tube = Tube(0,0,0,0)
        sky = Sky(0,0,0,0)
        ground = Ground(0,0,0,0)

        self.dict = {"Tube": type(tube), "Sky" : type(sky), "Ground": type(ground)}

    def generate(self, barrier_name):
        self.count += 1

        if barrier_name == "Sky":
            sky = Sky(0,0,WIDTH,SKY_WIDTH)
            if type(sky) is self.dict["Sky"]:
                return sky

        if barrier_name == "Ground":
            ground = Ground(0,HEIGHT-SAND_HEIGHT,WIDTH,SAND_HEIGHT)
            if type(ground) is self.dict["Ground"]:
                return ground

        if barrier_name == "Tube":
            TUBE_HEIGHT = random.randint(20,HEIGHT - SAND_HEIGHT - TUBE_GAP - 20)
            #TUBE_HEIGHT = self.__list_tube_height[self.index]
            self.index += 1

            tubeTop = Tube(WIDTH, 0, TUBE_WIDTH, TUBE_HEIGHT)
            tubeBottom = Tube(WIDTH, TUBE_HEIGHT + TUBE_GAP, TUBE_WIDTH, HEIGHT - SAND_HEIGHT - (TUBE_HEIGHT + TUBE_GAP))

            if type(tubeTop) and type(tubeBottom) is self.dict["Tube"]:
                return tubeTop, tubeBottom

        raise NameError("Wrong factory format")

#Bird class
from Sensor import *
from ANN import *

vec2 = pg.math.Vector2

class Bird(pg.sprite.Sprite):
    def __init__(self, genome = None):
        pg.sprite.Sprite.__init__(self)
        self.image = pg.image.load("images/bird1.png")
        self.rect = self.image.get_rect()
        self.rect.center = (WIDTH/2, random.randint(15,HEIGHT-SAND_HEIGHT)-5)

        #self.pos = vec2(WIDTH/2, HEIGHT/2)
        self.pos = vec2(WIDTH/2, random.randint(15,HEIGHT-SAND_HEIGHT)-5)

        self.vel = vec2(0,0)
        self.acc = vec2(0, GRAVITY)

        self.live = 1;

        self.sensor = Sensor()

        if genome is None:
            self.ANN = ANN()
        else:
            self.ANN = ANN(genome)
    def update(self):
        self.vel += self.acc
        self.pos += self.vel + self.acc
        self.rect.center = (self.pos[0], self.pos[1])

        if self.live == 1: #if bird alive then increase fitness
            self.ANN.fitness += FITNESS_RATE

    def flap(self):
        self.vel.y = JUMP_VELOCITY

#Game class
from Barrier_Factory import *
from Singleton import *

@Singleton
class Game:
    def __init__(self):
        self.barrier_factory = Barrier_Factory()
        self.__game_running__ = True #whole game, to configure quit command
        self.__game_playing__ = False #bird jumping -> true. Instruction screen -> false
        self.__score__ = 0 #best score
        self.__bird_list__ = [Bird() for i in range(POPULATION)] #all bird in a population
        self.screen = pg.display.set_mode((WIDTH,HEIGHT))
        self.screen.set_alpha(None)
        self.clock = pg.time.Clock()

        self.generation = 0
        self.generation_list = []

        self.average_fitness = 0
        self.average_fitness_list = []

        self.best_fitness_list = []

        pg.init()

    def new(self):
        self.barrier_factory.index = 0 #reset the factory so that a the set of tube remain unchanged

        self.__bird_list__.sort(key=lambda x: x.ANN.fitness, reverse=True) #SORT bird_list based on its fitness, from highest to lowest fitness

        #region Calculate average fitness (used for visualize growth rate)
        fitness_ave = 0
        for bird in self.__bird_list__:
            fitness_ave += bird.ANN.fitness
        fitness_ave = fitness_ave/POPULATION
        #endregion)

        self.average_fitness_list.append(round(fitness_ave))

        self.best_fitness_list.append(self.__bird_list__[0].ANN.fitness)

        self.generation_list.append(self.generation)

        #region Collect data
        print(self.average_fitness_list)
        print(self.best_fitness_list)
        print(self.generation_list)
        print()
        #endregion

        self.generation += 1

        self.barrier_factory.count = 0

        self.__bird_list__ = ANN.create_new_generation(self.__bird_list__)

        #region Barrier Factory generator
        self.tubeTop, self.tubeBottom = self.barrier_factory.generate("Tube")
        self.ground = self.barrier_factory.generate("Ground")
        self.sky = self.barrier_factory.generate("Sky")
        #endregion

        #region Add sprites to group of sprite
        self.all_birds = pg.sprite.Group()
        self.all_barrier = pg.sprite.Group()
        self.all_sprites = pg.sprite.Group()

        self.all_birds.add(self.__bird_list__)

        self.all_barrier.add(self.ground)
        self.all_barrier.add(self.sky)
        self.all_barrier.add(self.tubeBottom)
        self.all_barrier.add(self.tubeTop)

        self.all_sprites.add(self.all_birds)
        self.all_sprites.add(self.all_barrier)
        #endregion

    def update(self):
        self.__score__ = self.barrier_factory.count-3
        if len(self.all_birds) != 0: #update best __score__:
            self.__display_text__("Best score: " + str(self.__score__),10, 10, 20, BLACK)

        if self.tubeBottom.rect.x == WIDTH/2 - TUBE_WIDTH - BIRD_SIZE[0]: #increase score if bird pass through a tube
            self.tubeTop, self.tubeBottom = self.barrier_factory.generate("Tube")

            self.all_barrier.add(self.tubeBottom)
            self.all_barrier.add(self.tubeTop)

            self.all_sprites.add(self.all_barrier)

        #feed forward NN of each bird
        for bird in self.all_birds:
            bird.sensor.detect(bird, self.tubeTop, self.tubeBottom)
            output_NN = bird.ANN.feed_forward(np.array([[bird.sensor.dist_vertical],
                                                        [bird.sensor.dist_horizontal],
                                                        [TUBE_WIDTH],
                                                        [BIRD_SIZE[0]],
                                                        [BIRD_SIZE[1]]]))
            if output_NN > THRESHOLD:
                bird.flap()

        self.all_sprites.update()

    def events(self):
        for event in pg.event.get():
            if event.type == pg.QUIT:  # If user clicked close
                self.__game_running__ = False # Flag that we are done so we exit this loop

            #use space to make all bird jump
            if event.type == pg.KEYDOWN:
                if event.key == pg.K_SPACE: #jump space
                    #for bird in self.__bird_list__:
                        #bird.flap()
                    self.__bird_list__[0].flap()

        for i in range(0,POPULATION): #check collision
            birdCollide = pg.sprite.spritecollide(self.__bird_list__[i], self.all_barrier, False)
            if birdCollide:
                self.__bird_list__[i].live = 0
                self.all_birds.remove(self.__bird_list__[i])
                self.all_sprites.remove(self.__bird_list__[i])

        if len(self.all_birds) == 0: #dead birds are removed from group of bird sprite (all_bird)
            self.__game_playing__ = False

    def draw(self):

        #print ("all_birds: " + str(len(self.all_birds)))
        # print ("all sprites: " + str(len(self.all_sprites)))
        #print ("all barrier: " +str(len(self.all_barrier)))

        self.screen.blit(Background, [0, 0])

        for bird in self.all_birds: #Use blit instead of draw to have better speed
            self.screen.blit(bird.image, [bird.rect.x,bird.rect.y])

        for barrier in self.all_barrier:
            self.screen.blit(barrier.image, [barrier.rect.x, barrier.rect.y])

        if len(self.all_birds) != 0: #update best __score__:
            self.__display_text__("Best score: " + str(self.__score__),10, 10, 20, BLACK)

        if self.__bird_list__[0].live == 1: # draw two line from bird with data from bird.sensor
            pg.draw.line(self.screen, BLACK, (self.__bird_list__[0].rect.center[0], self.__bird_list__[0].rect.center[1]), (self.__bird_list__[0].rect.center[0] + self.__bird_list__[0].sensor.dist_horizontal, self.__bird_list__[0].rect.center[1]))
            pg.draw.line(self.screen, BLACK, (self.__bird_list__[0].rect.center[0], self.__bird_list__[0].rect.center[1]), (self.__bird_list__[0].rect.center[0] , self.__bird_list__[0].rect.center[1] + self.__bird_list__[0].sensor.dist_vertical))

        pg.display.flip()


    def run(self):
        while self.__game_playing__:
            self.clock.tick(FPS)
            self.events()
            self.update()
            self.draw()

    def start_screen(self):
        self.__game_playing__ = False
        while not self.__game_playing__:
            self.__display_text__("Flappy Bird",WIDTH / 3, HEIGHT / 3, 30, WHITE)
            self.__display_text__("Press S to Start...",WIDTH/3, HEIGHT / 2, 30, WHITE)
            pg.display.flip()
            for event in pg.event.get():
                if event.type == pg.QUIT:
                    raise SystemExit ## Exit game

                if event.type == pg.KEYDOWN and event.key == pg.K_s: #press S to start game
                    self.__game_playing__ = True

    def __display_text__(self, message, x, y, size, color):
        font = pg.font.SysFont("Comic Sans Ms", size)
        text = font.render(message, False, color)
        self.screen.blit(text, (x,y))

#Ground class
from settings import *
import pygame as pg

class Ground(pg.sprite.Sprite):
	def __init__(self,x,y,w,h):
		pg.sprite.Sprite.__init__(self)
		self.image = pg.Surface((w,h))
		self.image.fill(SAND)
		self.rect = self.image.get_rect()
		self.rect.x = x
		self.rect.y = y

#Main Class
from Game import *

g = Game.Instance()
g.start_screen()

while g.__game_playing__:
    #create new game
    g.new()

    #game loop
    g.run()

    #auto create new generation after all bird died
    g.__game_playing__ = True
    #g.start_screen() #recursive

#Sensor Class
from settings import *
from Bird import *
from Tube import *

class Sensor:
    def __init__(self):
        self.dist_vertical = 0 #distance from bird to middle point of the distance between 2 tubes
        self.dist_horizontal = 0 #distance from bird to tube

    def detect(self, bird, tube_top, tube_bottom):
        self.dist_horizontal = tube_bottom.rect.x + TUBE_WIDTH - bird.rect.center[0]
        self.dist_vertical = ((tube_bottom.rect.y - tube_top.height)/2 + tube_top.height) - bird.rect.center[1]

#Singleton class
class Singleton:
    """
    A non-thread-safe helper class to ease implementing singletons.
    This should be used as a decorator -- not a metaclass -- to the
    class that should be a singleton.

    The decorated class can define one `__init__` function that
    takes only the `self` argument. Also, the decorated class cannot be
    inherited from. Other than that, there are no restrictions that apply
    to the decorated class.

    To get the singleton instance, use the `Instance` method. Trying
    to use `__call__` will result in a `TypeError` being raised.

    Ref: https://stackoverflow.com/questions/6760685/creating-a-singleton-in-python
    """

    def __init__(self, decorated):
        self._decorated = decorated

    def Instance(self):
        """
        Returns the singleton instance. Upon its first call, it creates a
        new instance of the decorated class and calls its `__init__` method.
        On all subsequent calls, the already created instance is returned.

        """
        try:
            return self._instance
        except AttributeError:
            self._instance = self._decorated()
            return self._instance

    def __call__(self):
        raise TypeError('Singletons must be accessed through `Instance()`.')

    def __instancecheck__(self, inst):
       return isinstance(inst, self._decorated)

#Sky class
from settings import *
import pygame as pg

class Sky(pg.sprite.Sprite):
	def __init__(self,x,y,w,h):
		pg.sprite.Sprite.__init__(self)
		self.image = pg.Surface((w,h))
		self.image.fill(BLUE)
		self.rect = self.image.get_rect()
		self.rect.x = x
		self.rect.y = y

#Tube class
from settings import *

vec2 = pg.math.Vector2
class Tube(pg.sprite.Sprite):
    def __init__(self,x,y,w,h):
        pg.sprite.Sprite.__init__(self)
        self.image = pg.Surface((w,h))
        self.image.fill(GREEN)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.height = h

        # This is the tubes x velocity, giving the appearance of the player moving
        self.velX = TUBE_VELOCITY

    def update(self):
        # This is the cause of the tubes movement
        self.rect.x += self.velX

        # If a tube goes of the screen then it is 'killed'
        if self.rect.x + 100 < 0:
            self.kill()

#Setting, all constant variable
import pygame as pg
pg.mixer.init()

WIDTH, HEIGHT = 400,600

# Colors
# Primary Colors
BLACK = (  0,   0,   0)
WHITE = (255, 255, 255)
BLUE =  (  0,   0, 255)
GREEN = (  0, 255,   0)
RED =   (255,   0,   0)
SAND = (255,255,100)

FPS = 120

GRAVITY = 0.22
SAND_HEIGHT = 50

JUMP_VELOCITY = -7
TUBE_VELOCITY = -1
TUBE_WIDTH = 100
SKY_WIDTH = 5
TUBE_GAP = 150

bird_img = pg.image.load("images/bird1.png")
BIRD_SIZE = bird_img.get_size()

POPULATION = 50

INPUT_LAYER = 5
HIDDEN_LAYER = 4
OUTPUT_LAYER = 1
TOTAL_WEIGHT = (INPUT_LAYER+1)*HIDDEN_LAYER + (HIDDEN_LAYER+1)*OUTPUT_LAYER

THRESHOLD = 0.5

FITNESS_RATE = 1

MUTATION_RATE = 0.7
CROSSOVER_RATE = 0.6
SELECTION_RATE = 0.1 #0.15

SELECTION_PERCENTAGE = 0.1
MUTATION_PERCENTAGE = 0.60 #0.55
CROSSOVER_PERCENTAGE = 0.1 #0.15
#RANDOM_RATE = 0.20

Background = pg.image.load("images/background.png")

#Plot diagram
import numpy as np
import matplotlib.pyplot as plt
import scipy
from scipy import stats

x = np.asarray(gen_array)

y = np.asarray(best_fitness_array)
# fit with np.polyfit
print(scipy.stats.pearsonr(x, y))
m, b = np.polyfit(x, y, 1)

plt.plot(x, y, '.')
plt.plot(x, m*x + b, '-')
plt.xlabel('Generation')
plt.ylabel('Best Fitness Score')
plt.show()